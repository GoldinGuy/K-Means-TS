{"version":3,"file":"kmeans-ts.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["export interface KMeans {\r\n  iterations: number;\r\n  k: number;\r\n  indexes: Array<number>;\r\n  centroids: Centroids;\r\n}\r\n\r\nexport type UniMultiDimensionalArray = Array<any>; // needs to be able to handle array of any size\r\nexport type Vector = Array<number>;\r\nexport type Vectors = Array<Vector>;\r\nexport type Centroid = Array<number>;\r\nexport type Centroids = Array<Centroid>;\r\n\r\nconst MAX: number = 10000;\r\n\r\nfunction init(len: number, val: number, vect: Vector): Vector {\r\n  vect = vect || [];\r\n  for (let i = 0; i < len; i++) {\r\n    vect[i] = val;\r\n  }\r\n  return vect;\r\n}\r\n\r\nexport default function kmeans(\r\n  data: UniMultiDimensionalArray,\r\n  k: number,\r\n  init_cent?: String | Array<any>,\r\n  max_it?: number\r\n): KMeans {\r\n  let cents: Centroids = [];\r\n  let indexes: Array<number> = [];\r\n  let cent_moved: boolean = false;\r\n  let iterations: number = max_it || MAX;\r\n  let count: Vector = [];\r\n\r\n  if (!init_cent) {\r\n    let def_indexes: Array<boolean> = [];\r\n    let i: number = 0;\r\n    while (cents.length < k) {\r\n      let idx: number = Math.floor(Math.random() * data.length);\r\n      if (!def_indexes[idx]) {\r\n        def_indexes[idx] = true;\r\n        cents[i++] = data[idx];\r\n      }\r\n    }\r\n  } else if (init_cent === 'kmeans') {\r\n    cents = Cluster.k_means(data, k);\r\n  } else if (init_cent === 'kmeans++') {\r\n    cents = Cluster.k_means_pp(data, k);\r\n  } else {\r\n    cents = Array.from(init_cent);\r\n  }\r\n\r\n  do {\r\n    init(k, 0, count);\r\n    // For each value in data, find nearest centroid (Custom, multidimensional or one-dimensional)\r\n    for (const i in data) {\r\n      let min: number = Infinity;\r\n      let idx: number = 0;\r\n      for (let j = 0; j < k; j++) {\r\n        let dist: number =\r\n          data[0].length > 0\r\n            ? Distance.euclideanDist(data[i], cents[j])\r\n            : Math.abs(data[i][0] - cents[j][0]);\r\n        if (dist <= min) {\r\n          min = dist;\r\n          idx = j;\r\n        }\r\n      }\r\n      indexes[i] = idx; // Idx of centroid\r\n      count[idx]++; // Num values for centroid\r\n    }\r\n\r\n    // Recalculate centroids\r\n    let sum: UniMultiDimensionalArray = [];\r\n    let old: Centroids = [];\r\n    if (data[0].length > 0) {\r\n      for (let j = 0; j < k; j++) {\r\n        sum[j] = init(data[0].length, 0, sum[j]);\r\n        old[j] = cents[j];\r\n      }\r\n    } else {\r\n      for (let j = 0; j < k; j++) {\r\n        sum[j] = 0;\r\n        old[j] = cents[j];\r\n      }\r\n    }\r\n    // If multidimensional, sum values & accumulate value on the centroid for current vector for each centroid\r\n    if (data[0].length > 0) {\r\n      for (let j = 0; j < k; j++) {\r\n        cents[j] = [];\r\n      }\r\n      for (const i in data) {\r\n        for (let h = 0; h < data[0].length; h++) {\r\n          sum[indexes[i]][h] += data[i][h]; // Sum values for current centroid + Current vector\r\n        }\r\n      }\r\n      // Calculate the avg for each centroid\r\n      cent_moved = true;\r\n      for (let j = 0; j < k; j++) {\r\n        /* \r\n                sum[j] |  Sum of centroid values\r\n                old[j] | Old centroid value\r\n                count[j] | Num elements for centroid\r\n                */\r\n        let cent_j: Centroid = cents[j]; // Current centroid\r\n        for (let h = 0; h < data[0].length; h++) {\r\n          cent_j[h] = sum[j][h] / count[j] || 0; // Avg from new centroid\r\n        }\r\n        if (cent_moved) {\r\n          for (let h = 0; h < data[0].length; h++) {\r\n            if (old[j][h] != cent_j[h]) {\r\n              cent_moved = false;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // If one-dimensional, sum values & for each centroid, calculate avg, then determine if centroids moved\r\n    else {\r\n      for (const i in data) {\r\n        let idx: number = indexes[i];\r\n        sum[idx] += data[i];\r\n      }\r\n      for (let j = 0; j < k; j++) {\r\n        cents[j] = [sum[j] / count[j]] || [0];\r\n      }\r\n      cent_moved = true;\r\n      for (let j = 0; j < k; j++) {\r\n        if (old[j] != cents[j]) {\r\n          cent_moved = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    cent_moved = cent_moved || --iterations <= 0;\r\n  } while (!cent_moved);\r\n\r\n  const k_means_obj: KMeans = {\r\n    iterations: (max_it || MAX) - iterations,\r\n    k: k,\r\n    indexes: indexes,\r\n    centroids: cents,\r\n  };\r\n  return k_means_obj;\r\n}\r\n\r\nclass Cluster {\r\n  // K-means initial centroid selection\r\n  static k_means(data: Vectors, k: number): Centroids {\r\n    let cents: Centroids = [];\r\n    let t: number = k << 2;\r\n    let map = {};\r\n    while (cents.length < k && t-- > 0) {\r\n      let d: Array<number> = data[Math.floor(Math.random() * data.length)];\r\n      let key: string = data[0].length > 0 ? d.join('_') : `${d}`;\r\n      if (!map[key]) {\r\n        map[key] = true;\r\n        cents.push(d);\r\n      }\r\n    }\r\n    if (cents.length < k) {\r\n      throw Error('Failed to initialize clusters');\r\n    } else return cents;\r\n  }\r\n\r\n  // K-means++ initial centroid selection\r\n  static k_means_pp(data: Vectors, k: number): Centroids {\r\n    const distance: Function = data[0].length\r\n      ? Distance.euclideanDist\r\n      : Distance.dist;\r\n    let cents: Centroids = [];\r\n    let map = {};\r\n    // Initial random centroid\r\n    let c: Centroid = data[Math.floor(Math.random() * data.length)];\r\n    cents.push(c);\r\n    map[data[0].length > 0 ? c.join('_') : `${c}`] = true;\r\n    // Get next centroids\r\n    while (cents.length < k) {\r\n      // Find min distances between current centroids and data points\r\n      let distances: Array<number> = [];\r\n      let probs: Array<{\r\n        i: string;\r\n        v: Vector;\r\n        pr: number;\r\n        cs: number;\r\n      }> = [];\r\n      let d_sum: number = 0;\r\n      for (const i in data) {\r\n        let min: number = Infinity;\r\n        for (const j in cents) {\r\n          let dist: number = distance(data[i], cents[j]);\r\n          if (dist <= min) min = dist;\r\n        }\r\n        distances[i] = min;\r\n      }\r\n      // Sum min distances\r\n      for (const i in data) {\r\n        d_sum += distances[i];\r\n      }\r\n      // Probabilities/cumulative prob\r\n      for (const i in data) {\r\n        probs[i] = { i: i, v: data[i], pr: distances[i] / d_sum, cs: 0 };\r\n      }\r\n      probs.sort((a, b) => a.pr - b.pr);\r\n      // Cumulative probs\r\n      probs[0].cs = probs[0].pr;\r\n      for (let i = 1; i < data.length; i++) {\r\n        probs[i].cs = probs[i - 1].cs + probs[i].pr;\r\n      }\r\n      // Gets items where cum sum >= random num\r\n      let rnd: number = Math.random();\r\n      let idx: number = 0;\r\n      while (idx < data.length - 1 && probs[idx++].cs < rnd);\r\n      cents.push(probs[idx - 1].v);\r\n    }\r\n    return cents;\r\n  }\r\n}\r\n\r\nclass Distance {\r\n  // Absolute distance between two values\r\n  // d(x, y, z) = z ? || x - y || : || x - y || * || x - y ||\r\n  static dist(x: number, y: number, sqrt?: number): number {\r\n    const d: number = Math.abs(x - y);\r\n    return sqrt ? d : d * d;\r\n  }\r\n  // The \"ordinary\" straight-line distance between two points in Euclidean space\r\n  // ed((x1, y1), (x2, y2)) = || (x1, y1) – (x2, y2) ||\r\n  static euclideanDist(x: Centroid, y: Centroid): number {\r\n    let sum: number = 0;\r\n    for (const i in x) {\r\n      const d: number = (x[i] || 0) - (y[i] || 0);\r\n      sum += d * d;\r\n    }\r\n    return sum;\r\n  }\r\n  // The distance between two points measured along axes at right angles\r\n  // md((x1, y1), (x2, y2)) = | x1 – x2 | + | y1 – y2 |\r\n  static manhattanDist(x: Centroid, y: Centroid): number {\r\n    let sum: number = 0;\r\n    let d: number = 0;\r\n    for (const i in x) {\r\n      d = (x[i] || 0) - (y[i] || 0);\r\n      sum += d >= 0 ? d : -d;\r\n    }\r\n    return sum;\r\n  }\r\n}\r\nexport { Cluster, Distance };\r\n"],"names":["init","len","val","vect","i","Cluster","k_means","data","k","cents","t","map","length","d","Math","floor","random","key","join","push","Error","k_means_pp","distance","Distance","euclideanDist","dist","c","distances","probs","d_sum","min","Infinity","j","v","pr","cs","sort","a","b","rnd","idx","x","y","sqrt","abs","sum","manhattanDist","init_cent","max_it","indexes","cent_moved","iterations","count","Array","from","def_indexes","old","h","cent_j","centroids"],"mappings":"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"}